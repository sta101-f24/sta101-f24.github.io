{
  "hash": "063bf383904ed61a1ba8228427943c09",
  "result": {
    "engine": "knitr",
    "markdown": "---\n  title: \"Confidence intervals with the bootstrap\"\n---\n\n\nA $100\\times(1-\\alpha)\\%$ confidence interval is an interval $(L_n,\\,U_n)$ that contains the true value $\\theta$ of some quantity of interest with high probability across repeated sampling. In order to approximate such an interval in general, we use the bootstrap to approximate the sampling distribution of an estimator $\\hat{\\theta}$, and then we use the quantiles of that boostrap distribution to determine the bounds of our interval.\n\nThis primer leads you down the path of least resistance to...doing all that.\n\n## Setup\n\nLoad our packages as usual:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) \nlibrary(tidymodels) \n```\n:::\n\n\nNext, consider this lil' dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabb <- read_csv(\"asheville.csv\")\n\nabb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50 × 1\n     ppg\n   <dbl>\n 1  48  \n 2  40  \n 3  99  \n 4  13  \n 5  55  \n 6  75  \n 7  74  \n 8 169  \n 9  56.2\n10  74.5\n# ℹ 40 more rows\n```\n\n\n:::\n:::\n\n\nThese are data on the price per guest in USD (`ppg`) for a random sample of fifty Airbnb listings in 2020 for Asheville, NC. We are going to use these data to investigate what we would be expected to pay for an Airbnb in in Asheville, NC in June 2020. Here is what the data look like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(abb, aes(x = ppg)) + \n  geom_histogram() +\n  labs(x = \"Price per guest ($)\")\n```\n\n::: {.cell-output-display}\n![](computing-confidence_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nTo answer the question \"what was the typical or expected price,\" we can calculate a point estimate like the sample mean or sample median:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabb |> \n  summarize(mean = mean(ppg),\n            median = median(ppg))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n   mean median\n  <dbl>  <dbl>\n1  76.6   62.5\n```\n\n\n:::\n:::\n\n\nIn this case they disagree quite a bit, which in general is something you should think about, but for the purposes of this primer, we will set the issue aside and focus just on the sample mean as our estimate.\n\n## Approximating the sampling distribution of the mean with the bootstrap\n\nThe sampling distribution of the mean refers to the random variation we would observe in our mean estimate if we recomputed it based on many different hypothetical samples from the population (June 2020 Airbnb listings in Asheville, in this case). Unfortunately, we do not have many different samples from this population. We only have one sample. But *if* that sample is a decent approximation to the population (debateable, in this case), we can randomly generate different hypothetical samples from our sample (resamples), calculate a different mean for each, and look at the variation in those estimates.\n\nThis is dirty work, but thankfully the computer handles it with aplomb:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8675309) \n\nboot_dist_abb <- abb |>\n  specify(response = ppg) |>\n  generate(reps = 5000, type = \"bootstrap\") |>\n  calculate(stat = \"mean\")\n\nboot_dist_abb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResponse: ppg (numeric)\n# A tibble: 5,000 × 2\n   replicate  stat\n       <int> <dbl>\n 1         1  70.8\n 2         2  66.2\n 3         3  72.8\n 4         4  73.1\n 5         5  76.4\n 6         6  80.1\n 7         7  80.4\n 8         8  69.1\n 9         9  91.7\n10        10  74.1\n# ℹ 4,990 more rows\n```\n\n\n:::\n:::\n\n\nThe code works like this:\n\n-   `specify(response = ppg)`: this is a bookkeeping step where we tell the computer which column in our data frame we are studying. It's simple in this case because there is only one;\n-   `generate(reps = 5000, type = \"bootstrap\")`: this generates 5000 bootstrap datasets. In general, we want the numbers of replicates/repetitions to be large enough for the approximation to be good, but not so large that it takes a while to run or hogs all the memory on our computer. For the small applications in our course, 1000 - 5000 replicates should suffice;\n-   `calculate(stat = \"mean\")`: once we have the bootstrap datasets, we need to calculate the value of our desired statistic for each one. The variation in these estimates captures what we mean by \"sampling uncertainty.\" For these Airbnb data, the statistic we care about is the sample average or mean, so that's what we ask for, but there are several options: \"mean\", \"median\", \"sd\", \"prop\", \"diff in means\", \"diff in props\", and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(boot_dist_abb, aes(x = stat)) + \n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](computing-confidence_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Calculating an approximate confidence interval\n\nArmed with our bootstrap sample of different means, we can calculate a 95% confidence interval using the `quantile` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_dist_abb |>\n  summarize(\n    lower = quantile(stat, 0.025),\n    upper = quantile(stat, 0.975)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  lower upper\n  <dbl> <dbl>\n1  63.8  90.9\n```\n\n\n:::\n:::\n\n\nAlternatively, we can use this nifty command which gives the same numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nci_95_abb <- boot_dist_abb |>\n  get_confidence_interval(\n    point_estimate = mean(abb$ppg), \n    level = 0.95\n  )\nci_95_abb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  lower_ci upper_ci\n     <dbl>    <dbl>\n1     63.8     90.9\n```\n\n\n:::\n:::\n\n\nLastly, we can summarize it all with a picture:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvisualize(boot_dist_abb) +\n  shade_confidence_interval(ci_95_abb)\n```\n\n::: {.cell-output-display}\n![](computing-confidence_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThe correct language for interpreting our interval goes something like this:\n\n> We are 95% confident that the true mean price lies in between $65.55 and $88.45.\n\nBut what does \"95% confident\" actually mean? It refers to the reliability in repeated use of the method that was used to generate the interval. It does not say anything about the reliability of the specific interval (65.55, 88.45), which is a tad disappointing.\n\nThink of it this way: if each day for 1000 days, we collected a new random sample of prices, and calculated a 95% confidence interval for each of those samples, approximately 950 of those 1000 intervals would contain the truth. That's the sense in which the interval estimation method is 95% reliable. In practice however, we have one dataset and one interval. So how do we know if our interval is one of those lucky 950, or if we're one of the 50 that went astray? Welcome to statistics, folks. ",
    "supporting": [
      "computing-confidence_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}